Project TODO List (AI Multiplayer Mini-Game Hub)
This document outlines the development tasks based on the detailed PRD (Version 1.27). Tasks should be completed sequentially within phases where possible, and tested upon completion.
Phase 0: Project Setup & Foundation
* [ ] Environment Setup:
   * [ ] Install required Unity version.
   * [ ] Install Node.js and required packages (e.g., WebSocket library like Socket.io).
   * [ ] Set up IDE (Cursor/Roo/Cline) with Unity and Node.js integration.
   * [ ] Configure Blender AI/MCP integration (if available/needed for asset pipeline).
* [ ] Version Control:
   * [ ] Initialize Git repository.
   * [ ] Create initial commit.
   * [ ] Set up remote repository (e.g., GitHub).
* [ ] Project Structure:
   * [ ] Create initial Unity project folder structure (e.g., Scripts, Prefabs, Assets/Models, Assets/Sprites, Scenes, MiniGames/[GameName]).
   * [ ] Create initial Node.js backend project structure.
* [ ] Core Dependencies:
   * [ ] Install/Import necessary Unity packages (e.g., Input System, any required asset store tools).
   * [ ] Install necessary Node.js packages (npm install).
* [ ] AI Guidelines:
   * [ ] Define & Create rules.md file (AI Development Guidelines based on PRD Section 12). (Content drafted in ai_dev_rules_v1)
   * [ ] Review & Finalize rules.md content.
Phase 1: Core Systems & Hub Implementation
* [ ] Basic Unity Scene Setup:
   * [ ] Create Main Menu scene.
   * [ ] Create Lobby scene.
   * [ ] Create basic scene transition logic.
* [ ] Node.js Backend Basics:
   * [ ] Implement basic Node.js server.
   * [ ] Set up WebSocket (Socket.io) connection handling.
   * [ ] Implement basic client connection/disconnection logic.
* [ ] Main Menu/Hub UI:
   * [ ] Implement basic UI layout (Title, Buttons: Play Tournament, Select Mini-Game, Options, Quit).
   * [ ] Implement button functionality (scene transitions).
   * [ ] Designate area/trigger for Easter Egg activations.
* [ ] Lobby System:
   * [ ] Implement basic Lobby scene UI (Player list, Game settings placeholder, Ready button, Start Game button).
   * [ ] Implement basic lobby creation/joining logic on backend.
   * [ ] Implement player list synchronization between clients and server.
   * [ ] Implement Ready state logic.
* [ ] Basic Multiplayer Framework:
   * [ ] Establish basic communication between Unity client and Node.js server.
   * [ ] Implement simple test message sending/receiving.
   * [ ] Implement placeholder for player data synchronization.
* [ ] Core Systems (Placeholders):
   * [ ] Implement basic persistent currency tracking (placeholder, e.g., PlayerPrefs or simple file).
   * [ ] Implement basic global settings structure (e.g., for Ghost Mode toggle).
Phase 2: Mini-Game Implementation (Iterative)
(Repeat for each core mini-game: 6.1 to 6.5)
* [ ] Mini-Game: [Game Name - e.g., Jetpack Joyride Clone]
   * [ ] Scene/Module Setup: Create scene and basic script structure for the mini-game.
   * [ ] Core Gameplay:
      * [ ] Implement player character movement/controls (using placeholder visuals).
      * [ ] Implement core game mechanic (e.g., scrolling, lane switching, jumping).
      * [ ] Implement procedural generation for level/obstacles (using placeholder visuals).
      * [ ] Implement hazard collision and game over logic (single player).
      * [ ] Implement coin/collectible spawning and collection logic.
      * [ ] Implement power-up logic (if applicable for this game).
      * [ ] Implement scoring system (distance/time + coins).
   * [ ] Asset Integration (Placeholders):
      * [ ] Integrate basic player character visual (placeholder model/sprite).
      * [ ] Integrate basic hazard visuals (placeholder models/sprites).
      * [ ] Integrate basic environment visuals.
   * [ ] Multiplayer Integration:
      * [ ] Implement player representation (syncing position/state of remote players per Section 8).
      * [ ] Implement environment synchronization (hazards, etc., per Section 8).
      * [ ] Implement game state management (start, elimination, round end, spectate, results screen per game spec / Section 8).
      * [ ] Implement network considerations (update frequency, interpolation per Section 8).
   * [ ] Basic Testing: Test core mechanics and multiplayer sync in isolation.
Phase 3: Easter Egg Implementation
(Repeat for each defined Easter Egg: 7.1 to 7.12)
* [ ] Easter Egg: [Egg Name - e.g., Classic Snake]
   * [ ] UI Integration: Implement trigger and visual container within Hub UI.
   * [ ] Core Mechanics: Implement specific gameplay logic.
   * [ ] Controls: Implement PC/Mobile controls.
   * [ ] Reset Logic: Implement functionality for the reset button.
   * [ ] Basic Testing: Test activation, gameplay, and reset.
* [ ] Easter Egg: Bubble Shooter (7.13) (Requires detailed breakdown first)
   * [ ] Define detailed breakdown (Gameplay, Controls, etc.)
   * [ ] Implement based on breakdown
Phase 4: Asset Integration & Polish
* [ ] High-Quality Asset Integration (Blender -> Unity):
   * [ ] Integrate final Player Character models/sprites (per game).
   * [ ] Integrate final Hazard/Obstacle models/sprites (per game).
   * [ ] Integrate final Environment assets/themes (per game).
   * [ ] Integrate final UI assets (buttons, icons, fonts).
   * [ ] Update configuration files to reference final assets.
* [ ] Animation & Effects Polish:
   * [ ] Refine player animations (using final models/sprites).
   * [ ] Refine hazard animations.
   * [ ] Add/Refine particle effects (thrust, explosions, collection, etc.).
   * [ ] Implement UI animations/transitions.
* [ ] Shop Implementation:
   * [ ] Design and implement Shop UI.
   * [ ] Implement logic for purchasing/unlocking per-game characters using persistent currency.
   * [ ] Implement logic for selecting unlocked characters per game.
* [ ] Audio Implementation:
   * [ ] Integrate background music (Hub, per game).
   * [ ] Integrate sound effects (UI clicks, jumps, collisions, coin collection, power-ups, etc.).
Phase 5: Testing & Refinement
* [ ] Code Review & Refactoring Session: Review major systems (Core, Mini-Games) for clarity, maintainability, and performance improvements based on rules.md.
* [ ] Comprehensive Gameplay Testing:
   * [ ] Test all mini-games thoroughly (single player & multiplayer).
   * [ ] Test all Easter eggs.
   * [ ] Test core loop (hub, lobby, game transitions, results).
   * [ ] Test on all target platforms (PC, Mobile).
* [ ] Multiplayer Stress Testing:
   * [ ] Test with multiple concurrent players.
   * [ ] Test handling of disconnections/reconnections (if supported).
   * [ ] Test latency compensation effectiveness.
* [ ] Security Review: Audit backend code (Node.js) and communication points for common vulnerabilities.
* [ ] Bug Fixing: Address all identified bugs from testing phases.
* [ ] Performance Optimization: Profile and optimize CPU, GPU, and network usage.
* [ ] Usability Testing: Gather feedback on controls, UI clarity, and overall experience.
Phase 6: Documentation & Deployment
* [ ] Finalize Documentation:
   * [ ] Update README.md with final instructions.
   * [ ] Ensure code is well-commented.
* [ ] Build Preparation:
   * [ ] Configure build settings for PC platforms (Windows, Mac, Linux).
   * [ ] Configure build settings for Mobile platforms (iOS, Android).
* [ ] Deployment:
   * [ ] Create final builds.
   * [ ] (Optional: Outline deployment steps to specific platforms/stores).
   * [ ] Document release notes.
