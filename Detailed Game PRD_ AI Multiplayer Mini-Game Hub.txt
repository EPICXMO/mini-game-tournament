Product Requirements Document (PRD): AI Multiplayer Mini-Game Hub
Version: 1.28
Date: April 3, 2025
1. Introduction & Overview
This document outlines the requirements for the AI Multiplayer Mini-Game Hub project. The goal is to create a dynamic, engaging, and expandable multiplayer game platform inspired by the hub-and-spoke models of games like Fortnite and Roblox. Players can join a central hub, connect with friends, and jump into various classic and potentially unique mini-games, competing in tournaments or playing casually. The project emphasizes leveraging AI for development ("vibe coding"), asset creation (Blender+AI), and potentially gameplay elements, while ensuring a high-quality, cross-platform experience (including mobile).
2. Goals
* Develop a fun, engaging, and scalable multiplayer mini-game platform.
* Create a seamless user experience for joining games, playing with friends, and navigating the hub.
* Implement a robust technical foundation supporting real-time multiplayer across various platforms (PC, Mobile).
* Leverage AI tools (Cursor/Roo/Cline, MCP integrations) effectively for development, following "vibe coding" principles.
* Utilize AI-assisted workflows (Blender+MCP) for high-quality 2D/3D asset creation.
* Build a modular architecture allowing easy addition of new mini-games and features over time.
* Incorporate unique interactive elements (Easter egg mini-games) within the main hub/menu.
3. Target Audience
* Casual gamers looking for fun, quick-session multiplayer experiences.
* Groups of friends seeking a platform to play various mini-games together easily.
* Players who enjoy classic arcade and mobile game genres.
* Users interested in AI-generated content and novel game interactions.
4. Core Game Concept
* Hub-and-Spoke Model: A central interactive hub (lobby/main menu) serves as the primary navigation point.
* Game Selection: From the hub, players can browse and select from a library of available mini-games.
* Multiplayer Focus: Designed for real-time multiplayer sessions, enabling players to easily join lobbies, invite friends, and compete together. Focus on distance traveled and coin collection for scoring.
* Expandable Library: The architecture must support the continuous addition of new mini-games (both 2D and 3D) with varying complexity.
* Tournament Mode: A structured mode where players compete across a series of randomly selected mini-games to achieve the highest cumulative score.
* Casual Play: Option to play individual mini-games outside of the tournament structure.
* Interactive Hub: The main menu/lobby includes playful, interactive Easter egg mini-games for added engagement.
5. Game Flow
1. App Launch: User starts the game.
2. Main Hub/Menu: Player enters the central hub. This area is interactive and contains access points for Easter egg mini-games.
3. Game/Mode Selection: Player chooses to:
* Join/Create a Tournament Lobby.
* Select a specific mini-game for casual play.
* Join a friend's lobby/session.
4. Lobby/Waiting Room: Players gather before a game or tournament round starts. Ability to see connected friends, invite others, potentially customize characters (selected per game).
5. Mini-Game Launch: The selected mini-game loads with player using their chosen character for that specific game.
6. Gameplay: Players compete in the mini-game according to its specific rules.
7. Results Screen: Scores are displayed after the mini-game concludes. In tournament mode, cumulative scores are updated.
8. Return to Hub/Next Round: Players return to the main hub or proceed to the next mini-game in a tournament sequence.
9. Tournament End: Final scores are displayed, and a winner is declared.
10. Exit: Player closes the application.
6. Mini-Games (Core Gameplay)
The platform will feature a variety of mini-games. Each mini-game requires a detailed breakdown similar to the Easter Egg section below, covering Gameplay Mechanics, Controls, Scoring, Visuals, Technical Requirements, and Edge Cases. Additionally, multiplayer implementation details (Pass 2) and customization/extensibility details (Pass 3) will be specified for each game.
Initial Mini-Game List:
6.1. Jetpack Joyride Clone
   * Gameplay Mechanics & Interaction:
   * Endless Side-Scrolling: The player character automatically moves horizontally across a continuously scrolling level.
   * Vertical Control: The primary interaction involves controlling the player's vertical movement using a jetpack. Holding the input applies upward thrust; releasing it causes the player to descend due to gravity.
   * Floor Interaction: Hitting the floor is safe. The player character transitions to a running animation/state while on the floor and continues moving horizontally. Applying jetpack thrust lifts the player off the floor again.
   * Objective: Travel the maximum possible distance while avoiding hazards and collecting coins.
   * Hazards: Players must avoid various obstacles that appear procedurally (e.g., Zappers, Lasers, Missiles). (Specific types deferred for later detailing). Collision with a hazard results in game over.
   * Collectibles:
   * Coins: Scattered throughout the level for collection (secondary score/currency).
   * (Optional Power-ups/Vehicles deferred for later detailing).
   * Procedural Generation: Level layout, hazard placement, and collectible distribution are generated procedurally to ensure variety and replayability.
   * Controls (PC & Mobile):
   * Single Input:
   * PC: Hold Left Mouse Button OR Spacebar to activate jetpack thrust (ascend). Release to deactivate (descend).
   * Mobile: Hold screen tap anywhere to activate jetpack thrust (ascend). Release to deactivate (descend).
   * Scoring System:
   * Primary Score Component: Based directly on the horizontal distance traveled.
   * Secondary Score Component: Coins collected during the run.
   * Final Score Calculation: Follows the standard calculation defined in Section 9.
   * Persistent Currency: Collected coins also contribute to a persistent currency pool for the future Shop.
   * Visual Style & Assets (3D):
   * Style: Visually engaging 3D style (as specified in PRD). While gameplay is 2D side-scrolling, assets and environment have depth.
   * Player: 3D model of the player character with a visible, animated jetpack (particle effects for thrust). Running animation for floor interaction.
   * Environment: Multi-layered parallax scrolling background elements to create depth. Environment theme (e.g., laboratory, city, cave)? (Theme TBD)
   * Hazards: 3D models for all hazards (zappers, lasers, missiles, etc.) with clear visual cues and animations.
   * Collectibles: 3D models for coins and any optional power-ups/vehicles.
   * Effects: Particle effects for jetpack thrust, explosions (missiles, player death), coin collection feedback, power-up activation.
   * Asset Source: Primarily generated via Blender+AI (MCP) workflow.
   * Technical Requirements (Unity):
   * Engine: Unity (C#).
   * Scrolling: Smooth, continuous horizontal camera movement and background parallax scrolling.
   * Procedural Generation: Algorithm to generate level chunks with varied hazard patterns and collectible layouts.
   * Physics: Custom or Unity physics for player vertical movement (gravity, thrust). State machine for handling flying vs. running states.
   * Collision Detection: Accurate detection between player and hazards, player and coins/power-ups.
   * Animation: Smooth animations for player character (flying, running), hazards, and effects.
   * UI: Display for current distance score, coins collected, potentially pause menu.
   * Performance: Optimized for smooth framerate on target platforms (PC/Mobile), especially considering procedural generation and 3D assets.
   * Possible Edge Cases & Issues:
   * Player Stuck: Player finding a way to get stuck off-screen (top/bottom) or within geometry.
   * Impossible Patterns: Procedural generation creating unavoidable hazard combinations.
   * Performance Scaling: Ensuring performance remains stable as game speed/complexity increases over distance.
   * Difficulty Curve: Balancing the rate at which speed and hazard density increase.
   * Input Responsiveness: Ensuring immediate and reliable response to player input for thrust control.
   * Floor Transition: Smooth visual and physics transition between flying and running states.
   * Multiplayer Implementation Details (Pass 2):
   * Player Representation: Follows the global standard defined in Section 8 (real-time models/ghost toggle, names above head).
   * Synchronization & Fairness: Adheres to global standards (Section 8): Synchronized hazards/environment, instanced coins. Player Y-position, state (flying/running), and score require frequent synchronization. Power-ups (if added) affect only the collector but visuals may need sync.
   * Interaction: Adheres to global standard (Section 8): No direct player-player collision. Competition via score.
   * Game State Management: Adheres to global standards (Section 8): Round ends when last player crashes. Eliminated players Wait/Spectate. Final results screen ranks by score (Distance + Coins).
   * Network Considerations: Adheres to global standards (Section 8): Aim for high-quality real-time feel (target 10-20 updates/sec). Use interpolation for smoothness. Server validates final scores and hazard sequence. Minimize transmitted data (Y-pos, state).
   * Customization & Extensibility Details (Pass 3):
   * Player Character Customization: Player customization (selecting different characters/appearances unlocked via the Shop) is specific to this mini-game. Technical handling follows the global standard defined in Section 10 (support diverse models/scans, aim for auto-rigging/animation with fallbacks, adaptive collision, configurable FX points).
   * Hazard Customization (Developer/AI):
   * Visual Swapping: The system must allow the visual representation (3D model, sprite, texture) of predefined hazard types (e.g., Zapper, Laser, Missile) to be easily replaced with developer-provided assets as part of content updates/developer iteration, not as an end-player feature.
   * Consistent Behavior: Swapping a hazard's visual must not change its underlying collision shape, size, or gameplay effect by default. The system needs to associate the custom visual with the existing hazard logic and collider.
   * Workflow: Intended workflow involves developer creating asset -> developer provides asset to AI -> AI updates the reference for that hazard type in the configuration.
   * Environment Customization (Developer/AI):
   * Initial Theme: Implement one primary visual theme initially (e.g., Laboratory).
   * Architecture for Swapping: Design the background system (parallax layers, repeating elements, color palettes) in a modular way that allows for potential future theme swapping by the developer/AI (loading different sets of assets based on configuration).
   * Adding New Content (Developer/AI Extensibility):
   * Modular Design: Implement hazards and power-ups using a modular approach (e.g., base classes/interfaces like Hazard or PowerUp, potentially using Unity Prefabs with attached scripts).
   * Ease of Addition: Adding a new type of hazard or power-up should primarily involve the developer/AI creating a new script inheriting from the base class, defining its unique behavior and visuals, and registering it with the procedural generation system (e.g., adding it to a spawn list, potentially managed via configuration files). This minimizes changes needed in core game logic.
   * Asset Management:
   * Folder Structure: Organize project assets into clear, logical folders (e.g., Assets/MiniGames/JetpackJoyride/Characters/, Assets/MiniGames/JetpackJoyride/Hazards/Lasers/, Assets/MiniGames/JetpackJoyride/Environments/Lab/).
   * Configuration Files: Use configuration files (e.g., Unity ScriptableObjects, JSON) to link game logic elements to specific asset paths (models, textures, prefabs, sounds). This allows easier asset swapping by modifying the configuration rather than code. AI should be instructed to use and update these configuration files when implementing or changing assets.
6.2. Subway Surfers Clone
   * Gameplay Mechanics & Interaction:
   * Endless Forward Running (3D): Player character runs continuously forward ("into" the screen) along a path, typically divided into three distinct lanes (left, middle, right).
   * Lane Switching: Players must quickly switch between the three lanes to avoid obstacles and collect items.
   * Vertical Evasion: Players must jump over low obstacles or roll under high obstacles.
   * Objective: Travel the maximum possible distance (score) while collecting coins and avoiding collisions.
   * Obstacles: Various 3D obstacles appear in the lanes, requiring specific maneuvers to avoid. Examples:
   * Static barriers (require jumping over or switching lanes)
   * Overhead signals/bridges (require rolling under or switching lanes)
   * Oncoming or stationary trains (require switching lanes)
   * (Any other specific obstacles?)
   * Collectibles:
   * Coins: Arranged in patterns along the lanes.
   * Power-ups: Appear periodically for collection, providing temporary benefits:
   * Coin Magnet: Automatically attracts nearby coins to the player.
   * Super Sneakers: Allows the player to jump significantly higher.
   * 2X Multiplier: Doubles the rate at which the score multiplier increases for a duration.
   * Jetpack: Allows the player to fly above the track, avoiding all obstacles and collecting lines of coins.
   * Hoverboard: Provides temporary protection from one crash. Disappears after a collision or duration expires.
   * Procedural Generation: Track sections, obstacle placement, coin patterns, and power-up locations are generated procedurally across the three lanes.
   * Game Over: Colliding directly with an obstacle ends the run (unless a Hoverboard is active or the player has lives remaining).
   * Controls (PC & Mobile):
   * PC:
   * Left/Right Arrow Keys: Switch lanes left/right.
   * Up Arrow Key: Jump.
   * Down Arrow Key: Roll/Slide.
   * Spacebar: Activate Hoverboard (if collected).
   * Mobile:
   * Swipe Left/Right: Switch lanes left/right.
   * Swipe Up: Jump.
   * Swipe Down: Roll/Slide.
   * Double Tap Screen: Activate Hoverboard (if collected).
   * Scoring System:
   * Primary Score Component: Based on distance traveled.
   * Score Multiplier Effect: Multiplier increases score accumulation rate (details TBD, affects final score).
   * Secondary Score Component: Coins collected during the run.
   * Final Score Calculation: Follows the standard calculation defined in Section 9 (e.g., Base Score from Distance*Multiplier + Coins). (Exact formula TBD).
   * Persistent Currency: Collected coins also contribute to a persistent currency pool for the future Shop.
   * Visual Style & Assets (Fully 3D):
   * Style: Vibrant, fully 3D world.
   * Player: 3D character model with fluid animations for running, jumping, rolling, stumbling, and switching lanes.
   * Environment: Fully 3D environment, typically themed (e.g., subway tracks, city streets, tunnels). Procedurally placed track elements, background buildings/scenery. (Theme TBD)
   * Obstacles: Detailed 3D models for trains, barriers, signs, etc.
   * Collectibles: 3D models for coins and power-ups (Magnet, Sneakers, Multiplier, Jetpack, Hoverboard).
   * Effects: Particle effects for coin collection, power-up activation/duration (e.g., magnetic field, jetpack trail, hoverboard trail), impacts, speed lines, stumble/crash effects.
   * Camera: Typically a third-person perspective positioned behind and slightly above the player, following smoothly.
   * Asset Source: Primarily generated via Blender+AI (MCP) workflow.
   * Technical Requirements (Unity):
   * Engine: Unity (C#).
   * Character Controller: 3D controller managing forward movement, lane snapping/switching, jumping physics, rolling state.
   * Procedural Generation: Algorithm to generate 3D track segments with obstacles, collectibles, and power-ups distributed across the three lanes.
   * Collision Detection: 3D collision detection between the player and obstacles/collectibles.
   * Animation: Complex animation state machine for the player character (including stumble/recovery).
   * Input Handling: Responsive handling of keyboard inputs and swipe gestures (including double-tap detection for mobile hoverboard).
   * Power-up Logic: Implementing timers and effects for each power-up.
   * Life System: Tracking player lives (start with 3).
   * Camera Control: Smooth camera follow script.
   * UI: Display score, multiplier, coins, active power-up indicators (with timers), lives remaining, pause menu.
   * Performance: Optimization crucial due to continuous generation and rendering of a 3D world on target platforms (PC/Mobile).
   * Possible Edge Cases & Issues:
   * Lane Switching Glitches: Player getting stuck between lanes or snapping incorrectly.
   * Collision Accuracy: Ensuring collision detection is fair and accurate, especially during fast movements or lane changes.
   * Swipe Detection: Differentiating accurately between swipes (up/down/left/right) and taps/double-taps on mobile.
   * Performance Bottlenecks: Procedural generation or rendering complexity impacting framerate.
   * Unfair Generation: Procedural generation creating impossible-to-avoid obstacle patterns.
   * Camera Issues: Camera clipping through geometry or not keeping up with the player.
   * Power-up Stacking: Defining behavior if multiple power-ups are collected simultaneously (if possible).
   * Multiplayer Implementation Details (Pass 2):
   * Player Representation: Follows the global standard defined in Section 8 (real-time models/ghost toggle, names above head). Visuals for power-ups (jetpack, hoverboard) need to be synced.
   * Synchronization & Fairness: Adheres to global standards (Section 8): Synchronized track/obstacles/power-up placements, instanced coins. Player lane, vertical state (jump/roll), forward position/score, active power-ups, and remaining lives require frequent synchronization.
   * Interaction: Adheres to global standard (Section 8): No direct player-player collision. Players can visually overtake. Stumble/crash animations of others are visible.
   * Game State Management:
   * Lives: Players start with 3 lives. Collision consumes a life (unless Hoverboard active), triggers stumble/recovery.
   * Round End: Round ends when the last active player loses their final life.
   * Elimination: Players losing their final life see score and get Wait/Spectate options.
   * Results Screen: Ranks players by final score (Score calculation TBD, likely involves distance, multiplier, coins).
   * Network Considerations: Adheres to global standards (Section 8): Frequent updates needed for 3D positions/states. Use interpolation/prediction. Server validates final scores, life loss events, and environment sequence. Minimize data (send state changes).
   * Customization & Extensibility Details (Pass 3):
   * Player Character Customization: Player customization is specific to this mini-game. Technical handling follows the global standard defined in Section 10. Special attention required for ensuring custom models work with 3D run/jump/roll/stumble animations. Initial implementation for roll/crouch may use model scaling or collider adjustment, with future support for swapping pre-posed models (Fallback Option B).
   * Hazard/Obstacle Customization (Developer/AI): Complex obstacles (trains) use default models initially. System should support visual swapping (model/texture) for simpler obstacles (barriers) by developer/AI via configuration, maintaining consistent collision behavior (as per 6.1). User-provided 2D images could potentially be applied as textures onto simple 3D shapes for some obstacles.
   * Environment Customization (Developer/AI): Implement one initial theme (e.g., Subway). Build with modular elements to allow potential future swapping/addition of individual environment props by developer/AI via configuration. Full theme swapping is lower priority.
   * Adding New Content (Developer/AI Extensibility): Follows modular design principles (Section 6.1): Use base classes/prefabs for obstacles, power-ups, track segments. New types added via new derived classes/prefabs registered in configuration.
   * Asset Management: Follows principles from Section 6.1: Use clear folder structures and configuration files for linking logic to 3D assets.
6.3. Geometry Dash Clone
   * Gameplay Mechanics & Interaction:
   * Automatic Side-Scrolling & Procedural Generation: The player character (a geometric cube) moves automatically horizontally across a 2D level composed of procedurally generated segments.
   * Rhythm-Based Platforming: The core mechanic involves precisely timed single inputs (jumps) to navigate complex sequences of geometric obstacles (spikes, blocks, saws).
   * Obstacle Avoidance: Players must jump over or onto obstacles/platforms to avoid crashing. Collision with most hazards results in immediate failure/restart (single life).
   * Player Mode: Gameplay focuses solely on the basic cube jump mechanic. (No other vehicle modes for now).
   * Special Platforms: Include distinct platform types:
   * Bounce Platform: Jumping onto or hitting this platform launches the player significantly higher than a normal jump.
   * Low-Gravity Bounce Platform: Jumping onto or hitting this platform launches the player significantly higher AND temporarily applies reduced gravity, causing a slower descent.
   * Objective: Travel the maximum possible distance.
   * Controls (PC & Mobile):
   * Single Input:
   * PC: Left Mouse Button OR Spacebar OR Up Arrow Key to Jump.
   * Mobile: Tap screen anywhere to Jump.
   * Scoring System:
   * Primary Score Component: Based directly on the horizontal distance traveled.
   * Secondary Score Component: Coins collected during the run.
   * Final Score Calculation: Follows the standard calculation defined in Section 9 (Distance + Coins).
   * Persistent Currency: Collected coins also contribute to a persistent currency pool for the future Shop.
   * Note on Currency: The collected coins are intended to be used in a future Shop feature (details deferred) to unlock customizations (like different cube appearances) specific to this mini-game. The system needs to track this persistent currency.
   * Visual Style & Assets (2D):
   * Style: Clean, geometric aesthetic. Often uses bright, contrasting, or neon colors. Backgrounds can be abstract or themed but should not obscure gameplay elements.
   * Player: Simple geometric cube shape with basic animations (e.g., rotation on jump). (Custom appearances unlockable via Shop later).
   * Obstacles: Clearly defined geometric shapes (spikes, blocks, saws, standard platforms) that are easily distinguishable from safe surfaces and background elements.
   * Special Platforms: Bounce Platform and Low-Gravity Bounce Platform must have distinct visual appearances to signal their function.
   * Collectibles: Visual representation for Coins.
   * Environment: 2D backgrounds, potentially with simple parallax effects. Visual elements might pulse or react to background music (optional).
   * Effects: Particle effects for jumping, crashing/death, collecting coins, hitting special platforms.
   * Asset Source: Can be simple vector graphics or sprites, potentially generated via AI tools or created directly in Unity/external software.
   * Technical Requirements (Unity):
   * Engine: Unity (C#) using 2D tools.
   * Movement: Precise character movement logic (automatic horizontal speed, controlled jump height/arc). Physics might be custom for exact control.
   * Procedural Generation: Algorithm for procedural generation of 2D level segments including standard obstacles, special platforms, and coin placements.
   * Special Platform Logic: Implementation of unique physics interactions for Bounce and Low-Gravity Bounce platforms (modifying jump force and/or gravity scale temporarily).
   * Input Handling: Highly responsive, low-latency input detection.
   * Collision Detection: Accurate 2D collision detection (player vs hazards, player vs platforms, player vs coins).
   * Audio Synchronization: (Optional but recommended) System to potentially synchronize gameplay events/visuals with background music.
   * Persistent Currency: System to track coins collected and store the total persistently (likely managed via the backend or player save data).
   * UI: Display distance score, collected coins (session and/or total persistent), pause menu.
   * Possible Edge Cases & Issues:
   * Input Lag: Delay affecting precise jump timing.
   * Unfair Collisions: Player crashing despite visually clearing obstacles (requires precise hitboxes).
   * Procedural Generation Issues: Creating impossible sections, poor flow between segments, incorrect special platform placement.
   * Special Platform Physics: Ensuring bounce/gravity effects feel right and are bug-free.
   * Performance: Maintaining stable framerate, especially with procedural generation and effects.
   * Difficulty Balancing: Ensuring the procedural generation creates a fair and engaging difficulty curve.
   * Multiplayer Implementation Details (Pass 2):
   * Player Representation: Follows the global standard defined in Section 8 (real-time models/ghost toggle, names above head). Player cube's jump/fall state needs visual sync.
   * Synchronization & Fairness: Adheres to global standards (Section 8): Synchronized level segments/obstacles/platforms, instanced coins. Player horizontal progress (distance) and jump inputs/timing require synchronization.
   * Interaction: Adheres to global standard (Section 8): No direct player-player collision. Competition via score.
   * Game State Management: Adheres to global standards (Section 8): Instant death on collision (single life per run). Round ends when last player crashes. Eliminated players Wait/Spectate. Final results screen ranks by score (Distance + Coins).
   * Network Considerations: Adheres to global standards (Section 8): Synchronizing jump inputs precisely is key. Server validates final scores and level sequence. Use interpolation for visual smoothing of remote players.
   * Customization & Extensibility Details (Pass 3):
   * Player Character Customization: Player customization is specific to this mini-game. Technical handling follows the global standard defined in Section 10. (Focus on swapping 2D sprite/material/mesh for the cube player).
   * Hazard Customization (Developer/AI): System must support visual swapping (sprite/color) for predefined hazard types (spikes, blocks, saws) by developer/AI via configuration, maintaining consistent collision (as per 6.1).
   * Special Platform Customization (Developer/AI): System must support visual swapping (sprite/color) for special platform types (Bounce, Low-Gravity Bounce) by developer/AI via configuration, maintaining consistent function/collision.
   * Environment Customization (Developer/AI): Implement one initial theme. Build background elements modularly to allow potential future swapping/addition of different 2D background sets/themes by developer/AI via configuration. This is lower priority than player/hazard customization.
   * Adding New Content (Developer/AI Extensibility): Follows modular design principles (Section 6.1): Use base classes/prefabs for obstacles and special platforms. New types added via new derived classes/prefabs registered in configuration.
   * Asset Management: Follows principles from Section 6.1: Use clear folder structures and configuration files for linking logic to 2D assets (sprites, materials).
6.4. Dino Runner Clone
   * Gameplay Mechanics & Interaction:
   * Automatic Side-Scrolling: The player character (e.g., a dinosaur) runs automatically from left to right across a flat 2D landscape.
   * Jump Mechanic: The primary interaction is a single input jump to avoid obstacles. There is no ducking mechanic.
   * Obstacle Avoidance: Players must time jumps correctly to clear oncoming obstacles. Obstacles include:
   * Cacti (varying sizes/groupings on the ground).
   * Flying Obstacles (e.g., Pterodactyls): These appear at different heights. Some fly low, requiring a jump to avoid. Others fly high, acting as "fake-outs" that the player should not jump for, passing safely overhead if the player stays on the ground.
   * (Any other specific obstacles?)
   * Increasing Difficulty: The game speed gradually increases over time, making reaction times shorter and obstacle patterns more challenging.
   * Objective: Survive for the maximum possible distance.
   * Game Over: Collision with any obstacle (ground or low-flying) ends the run.
   * Controls (PC & Mobile):
   * Single Input (Jump):
   * PC: Spacebar OR Up Arrow Key OR Left Mouse Button to Jump.
   * Mobile: Tap screen anywhere to Jump.
   * (Optional: Variable jump height based on input duration? Or fixed jump height?)
   * Scoring System:
   * Primary Score Component: Based directly on the horizontal distance traveled or time survived, often represented by a simple counter.
   * Secondary Score Component: Collect Coins placed strategically (e.g., above obstacles) during the run.
   * Final Score Calculation: Follows the standard calculation defined in Section 9 (Distance + Coins).
   * Persistent Currency: Collected coins also contribute to a persistent currency pool (for the future Shop).
   * (Any other scoring elements, like points for near misses?)
   * Visual Style & Assets (2D):
   * Style: Simple 2D visuals. Often uses a minimalist aesthetic (like monochrome or limited colors, similar to the Chrome offline game), but could be adapted.
   * Player: 2D sprite for the player character (e.g., dinosaur) with running and jumping animations.
   * Obstacles: Simple 2D sprites for obstacles (cacti, pterodactyls, etc.), clearly indicating height for flying obstacles.
   * Environment: Basic scrolling ground line. Simple background elements like clouds or distant scenery. Optional day/night cycle visuals based on score/time.
   * Collectibles: Visual representation for Coins.
   * Effects: Minimal particle effects (e.g., dust trail while running, simple effect on jump/landing/crash).
   * Asset Source: Simple sprites, potentially AI-generated or created directly.
   * Technical Requirements (Unity):
   * Engine: Unity (C#) using 2D tools.
   * Movement: Character controller with automatic horizontal movement and controlled jump physics (gravity, jump force).
   * Procedural Generation: Algorithm to spawn obstacles (cacti, different height flying obstacles) at appropriate intervals based on increasing game speed and difficulty. Must ensure fair placement of high vs. low flying obstacles.
   * Speed Increase: System to gradually increase the horizontal scrolling speed over time.
   * Collision Detection: Accurate 2D collision detection between player and obstacles/ground/coins.
   * Animation: Simple sprite animation handling (running, jumping).
   * Persistent Currency: System to track collected coins for the persistent pool.
   * UI: Display current score (distance/time), collected coins.
   * Possible Edge Cases & Issues:
   * Unfair Spawning: Obstacles appearing too close together or fake-outs appearing unfairly, making avoidance impossible at high speeds.
   * Inconsistent Jump: Jump height or trajectory feeling unreliable.
   * Collision Hitboxes: Imprecise hitboxes causing unfair deaths or allowing players to pass through obstacles.
   * Performance: Ensuring smooth performance even as game speed increases significantly.
   * Difficulty Scaling: Balancing the speed increase and obstacle frequency/type (including fake-outs) effectively.
   * Visual Clarity: Ensuring high vs. low flying obstacles are easily distinguishable.
   * Multiplayer Implementation Details (Pass 2):
   * Player Representation: Follows the global standard defined in Section 8 (real-time models/ghost toggle, names above head). Player sprite's jump/run state needs visual sync.
   * Synchronization & Fairness: Adheres to global standards (Section 8): Synchronized obstacles (types, positions, heights), instanced coins. Player horizontal progress (distance) and jump inputs/timing require synchronization. Game speed increase must be synchronized.
   * Interaction: Adheres to global standard (Section 8): No direct player-player collision. Competition via score.
   * Game State Management: Adheres to global standards (Section 8): Instant death on collision (single life per run). Round ends when last player crashes. Eliminated players Wait/Spectate. Final results screen ranks by score (Distance + Coins).
   * Network Considerations: Adheres to global standards (Section 8): Synchronizing jump inputs precisely is key. Server validates final scores and obstacle sequence. Use interpolation for visual smoothing of remote players.
   * Customization & Extensibility Details (Pass 3):
   * Player Character Customization: Player customization is specific to this mini-game. Technical handling follows the global standard defined in Section 10. (Focus on swapping 2D sprite for the dinosaur).
   * Hazard Customization (Developer/AI): System must support visual swapping (sprite) for predefined hazard types (cacti, pterodactyl) by developer/AI via configuration, maintaining consistent collision (as per 6.1).
   * Environment Customization (Developer/AI): Implement one initial theme (e.g., desert). Build background/ground elements modularly to allow potential future swapping/addition by developer/AI via configuration.
   * Adding New Content (Developer/AI Extensibility): Follows modular design principles (Section 6.1): Use base classes/prefabs for obstacles. New types added via new derived classes/prefabs registered in configuration.
   * Asset Management: Follows principles from Section 6.1: Use clear folder structures and configuration files for linking logic to 2D assets (sprites).
6.5. Space Dodger Clone
   * Gameplay Mechanics & Interaction:
   * Objective: Survive as long as possible by maneuvering a spaceship to dodge incoming asteroids and potentially destroy them.
   * View Perspective: Side-scrolling view. (e.g., Player moves vertically on the left side, obstacles scroll horizontally from the right).
   * Movement: Player controls the spaceship's movement primarily on one axis (e.g., vertical axis if scrolling horizontally) within defined screen bounds.
   * Obstacle Avoidance: Dodge procedurally spawned asteroids of various sizes and speeds scrolling into view from one edge of the screen (e.g., the right edge). No enemy ships.
   * Shooting Mechanic:
   * The player's ship can shoot projectiles forward (in the direction opposite the scroll) to destroy asteroids.
   * Limited Ammo: The player has a limited number of shots available (e.g., starts with 1). Ammo does not regenerate automatically; players cannot spam shots.
   * Collectibles:
   * Coins: Appear periodically, often in safe paths between obstacles, for the persistent currency pool.
   * Power-ups: Appear periodically:
   * Extra Ammo: Grants one additional shot to the player's limited ammo count.
   * Shield: Provides temporary protection from one collision.
   * Speed Boost: Temporarily increases the ship's movement speed (vertical speed in this example).
   * (Any other power-ups?)
   * Increasing Difficulty: Asteroid density, speed, and/or complexity increases over time/distance traveled.
   * Game Over: Collision with an asteroid ends the run (unless a shield is active).
   * Controls (PC & Mobile):
   * PC:
   * Movement: Up/Down Arrow Keys OR W/S keys (for vertical movement if scrolling horizontally).
   * Shoot: Spacebar OR Left Mouse Button (consumes one ammo if available).
   * Mobile:
   * Movement: Touch-and-drag vertically on the screen OR Tap top/bottom screen halves.
   * Shoot: Dedicated on-screen button OR Tap on a specific screen area (consumes one ammo if available).
   * Scoring System:
   * Primary Score Component: Based primarily on time survived or distance traveled (based on scroll speed). Points are also awarded for destroying asteroids.
   * Secondary Score Component: Number of Coins collected.
   * Final Score Calculation: Follows the standard calculation defined in Section 9 (Time/Distance Score + Asteroid Points + Coins). (Exact formula TBD).
   * Persistent Currency: Collected coins also contribute to the persistent pool.
   * Visual Style & Assets (2D):
   * Style: 2D space theme (Side-scrolling perspective). Retro pixel art, clean vector style, or more detailed sprites.
   * Player: 2D sprite for the player's spaceship with animations/effects for vertical movement/thrust.
   * Obstacles: 2D sprites for asteroids, varying in size, shape, rotation, and speed, scrolling across the screen.
   * Environment: Scrolling background (e.g., starfield, nebula). Parallax effects can add depth.
   * Collectibles: 2D sprites for Coins and Power-ups (Ammo, Shield, Speed Boost).
   * Projectiles: 2D sprite/effect for player projectiles moving opposite the scroll direction.
   * Effects: Particle effects for ship thrust, explosions (player death, destroyed asteroids), projectile trails, shield activation, coin collection, power-up collection.
   * Asset Source: Sprites potentially generated via AI tools or created directly.
   * Technical Requirements (Unity):
   * Engine: Unity (C#) using 2D tools.
   * Movement: 2D controller for side-scrolling spaceship movement (vertical input). Clamp movement within screen bounds (top/bottom).
   * Scrolling: System for continuously scrolling background and spawning/moving obstacles from one edge (e.g., right) to the other (e.g., left).
   * Procedural Spawning: System to spawn asteroids (and coins/power-ups) from off-screen (e.g., right edge) with varying vertical positions, speeds, and frequencies based on difficulty progression.
   * Shooting Logic: Handling projectile firing direction (opposite scroll), speed, lifetime, and ammo consumption/tracking.
   * Collision Detection: Accurate 2D collision detection (player vs asteroids, player vs collectibles, projectiles vs asteroids). Asteroids might break into smaller pieces upon being hit (optional complexity).
   * Power-up Logic: Implementing timers and effects for collected power-ups (Shield, Speed Boost, adding ammo).
   * Difficulty Scaling: System to increase scroll speed, spawn rates, or asteroid speeds over time.
   * Persistent Currency: Tracking collected coins.
   * UI: Display score (time/distance), collected coins, current ammo count, lives (if applicable), active power-up indicators.
   * Possible Edge Cases & Issues:
   * Player Trapped: Spawning patterns creating unavoidable vertical walls of asteroids.
   * Control Issues: Unresponsive or inaccurate vertical movement controls.
   * Collision Problems: Unfair collisions or objects passing through each other. Hitboxes need to be precise.
   * Off-Screen Spawning: Asteroids spawning too close to the edge the player is near.
   * Performance: Slowdown when many asteroids/effects are on screen, especially at high scroll speeds.
   * Ammo Management: Balancing the availability of ammo power-ups with the challenge.
   * Visual Clutter: Too many objects making it hard to track the player ship and hazards.
   * Multiplayer Implementation Details (Pass 2):
   * Player Representation: Follows the global standard defined in Section 8 (real-time models/ghost toggle, names above head). Player ship's vertical position and shooting actions need visual sync.
   * Synchronization & Fairness: Adheres to global standards (Section 8): Synchronized asteroids (positions, speeds, types), instanced coins, instanced power-ups. Player vertical position, score, ammo count, active power-ups, and shooting actions require synchronization.
   * Interaction: Adheres to global standard (Section 8): No direct player-player collision. Player projectiles likely only affect asteroids, not other players. Competition via score.
   * Game State Management: Adheres to global standards (Section 8): Collision with asteroid ends run (single life unless Shield active). Round ends when last player crashes. Eliminated players Wait/Spectate. Final results screen ranks by score (Time/Distance + Asteroid Points + Coins).
   * Network Considerations: Adheres to global standards (Section 8): Synchronize player vertical position, shots fired (event-based), power-up states. Server validates final scores, asteroid destruction points, and obstacle sequence. Use interpolation for visual smoothing.
   * Customization & Extensibility Details (Pass 3):
   * Player Character Customization: Player customization is specific to this mini-game. Technical handling follows the global standard defined in Section 10. (Focus on swapping 2D sprite for the spaceship).
   * Hazard Customization (Developer/AI): System must support visual swapping (sprite) for asteroids by developer/AI via configuration, maintaining consistent collision (as per 6.1).
   * Environment Customization (Developer/AI): Implement one initial theme (e.g., starfield). Build background elements modularly to allow potential future swapping/addition by developer/AI via configuration.
   * Adding New Content (Developer/AI Extensibility): Follows modular design principles (Section 6.1): Use base classes/prefabs for obstacles (asteroids) and power-ups. New types added via new derived classes/prefabs registered in configuration.
   * Asset Management: Follows principles from Section 6.1: Use clear folder structures and configuration files for linking logic to 2D assets (sprites).
(Section 6.6 removed)
   7. (Future additions possible)
7. Interactive Easter Egg Mini-Games (Hub/Menu)
These are small, interactive games playable directly within the main menu/hub interface for fun and engagement.
General Requirements for All Easter Eggs:
   * Activation: Triggered by specific clicks or interactions within the hub UI.
   * Reset Button: A clearly visible button (e.g., circular arrow icon) must be present during Easter egg activation, allowing the player to instantly reset the menu/hub to its normal state and exit the Easter egg.
   * Non-Obstructive: Easter egg gameplay should not permanently block access to core navigation elements (like game selection buttons).
   * Performance: Must be lightweight and perform smoothly on all target platforms (PC, Mobile).
Specific Easter Egg Breakdowns:
7.1. Classic Snake
   * Gameplay Mechanics & Interaction:
   * Classic snake controls (Arrow keys/WASD for PC, on-screen controls for mobile).
   * Player navigates a snake around the menu background elements.
   * Snake grows when eating "food" items (disguised menu icons) appearing randomly around the lobby screen.
   * Collision with menu text elements (e.g., game selection buttons) or screen boundaries kills the snake (ends the mini-game).
   * Visual Elements:
   * Snake visually stylized to fit the menu aesthetic.
   * "Food" items appear as small, distinct icons or elements.
   * Technical Requirements:
   * Simple 2D movement and collision logic.
   * Integration with the Unity UI system.
   * Efficient performance.
   * Possible Edge Cases & Issues:
   * Ensure food doesn't spawn in impossible-to-reach locations.
   * Prevent snake from completely obscuring critical buttons before reset.
   * Handling boundary collisions.
7.2. Physics-Based Menu Text
   * Gameplay Mechanics & Interaction:
   * Players click and drag menu text items (like titles or buttons).
   * Dragged items behave with realistic physics (collide, bounce, fall).
   * Interactions can potentially cause text elements to "break" or fragment visually in addition to moving.
   * Players can playfully disrupt the menu layout.
   * Visual Elements:
   * Text behaves like physical objects.
   * Smooth animations for movement, collision, breaking, and settling.
   * Optional satisfying sound effects for interactions.
   * Technical Requirements:
   * Integration with Unity's physics engine.
   * Interactive elements clearly defined and separated from static UI.
   * Logic for visual "breaking" effect on text elements.
   * Optimized physics for performance.
   * Possible Edge Cases & Issues:
   * Ensure critical buttons remain clickable even when moved or broken.
   * Prevent text elements from falling off-screen permanently before reset.
   * Ensure "breaking" effect is visually clear but doesn't hinder readability excessively before reset.
7.3. Explodable Text
   * Gameplay Mechanics & Interaction:
   * Players click on individual letters or words in the menu.
   * Clicked text explodes into small pieces with satisfying effects.
   * Pieces scatter realistically based on physics.
   * Visual Elements:
   * Vivid explosion animations (particle effects).
   * Smooth transition from text to exploded fragments.
   * Optional explosion sound effects.
   * Technical Requirements:
   * Unity's particle system and physics engine.
   * Interactive text objects clearly defined.
   * Optimized effects for performance.
   * Possible Edge Cases & Issues:
   * Ensure explosions don't obscure critical UI elements for too long.
   * Limit simultaneous explosions if performance becomes an issue.
   * Reset button must be easily accessible.
7.4. Gravity Flip
   * Gameplay Mechanics & Interaction:
   * Player character appears on top of menu elements upon activation; environment initially appears normal.
   * Players can flip the direction of gravity affecting menu items (text, icons, buttons).
   * Controls:
   * PC: Arrow keys or UHJK keys to change gravity direction (Up, Down, Left, Right). WASD to move the character.
   * Mobile: On-screen D-pad/arrows on the left for character movement, on-screen D-pad/arrows on the right for gravity direction control.
   * Menu items float, fall, or slide based on the current gravity direction.
   * Visual Elements:
   * Menu items respond realistically to gravity changes.
   * Smooth animations for floating, falling, and shifting.
   * Player character is visible and interacts with the shifting menu elements.
   * Technical Requirements:
   * Unity physics simulation for dynamic gravity.
   * Intuitive controls for both PC and mobile.
   * Optimized physics handling.
   * Possible Edge Cases & Issues:
   * Ensure menu items don't permanently stack or clump in a way that blocks critical buttons.
   * Character movement should feel responsive within the chaotic environment.
   * Reset button must reliably restore layout and standard gravity.
7.5. Menu Pong (Breakout Hybrid)
   * Gameplay Mechanics & Interaction:
   * Activates a Pong/Breakout hybrid game within the menu space.
   * Player controls a paddle (white rectangle) at the bottom.
   * PC: Mouse movement.
   * Mobile: Finger drag.
   * An AI bot controls an opposing paddle at the top.
   * A ball bounces between paddles.
   * Menu text elements act as "bricks". When the ball hits a text element, the text "breaks" (disappears or shows damage) and the ball bounces off (like Breakout).
   * The goal is Pong-like: get the ball past the opponent's paddle to score.
   * Visual Elements:
   * Standard Pong paddles (player and bot).
   * Ball visually distinct.
   * Text elements react visually to ball collisions (breaking animation/effect).
   * Clear scoring indication.
   * Technical Requirements:
   * 2D physics for ball movement, paddle collision, and text collision.
   * Basic AI for the opponent paddle.
   * Responsive controls (mouse/touch).
   * Integration with UI elements as breakable bricks.
   * Possible Edge Cases & Issues:
   * Ball getting stuck in geometry.
   * Ensuring broken text doesn't leave gaps that make core menu unusable before reset.
   * Balancing bot difficulty.
   * Clear distinction between gameplay and interactive menu items.
7.6. Paint Splatter
   * Gameplay Mechanics & Interaction:
   * Players interact directly with the menu screen using mouse clicks (PC) or touch gestures (mobile), leaving colorful paint splatters and trails.
   * Different gestures create varied splatter patterns and sizes.
   * Visual Elements:
   * Bright, vivid paint colors with realistic splatter effects.
   * Dynamic animations for paint appearance and dripping.
   * Technical Requirements:
   * Efficient rendering to handle multiple overlapping effects (shaders or decals recommended).
   * Mouse and multi-touch input support.
   * Possible Edge Cases & Issues:
   * Ensuring painted elements don't obscure essential buttons.
   * Clear reset functionality to restore the original layout quickly.
   * Handling excessive layering of paint effects gracefully without degrading performance.
7.7. Cursor Chase
   * Gameplay Mechanics & Interaction:
   * Menu elements (buttons, icons) actively evade cursor interactions (PC mouse / mobile touch), providing playful challenges.
   * Players aim to successfully click on moving elements.
   * Visual Elements:
   * Smooth evasion animations with clear visual feedback upon successful interaction (e.g., glow, shake).
   * Technical Requirements:
   * Responsive cursor/touch detection and optimized animations.
   * Accessible controls for both desktop (mouse cursor) and mobile (touch interactions).
   * Possible Edge Cases & Issues:
   * Ensuring essential menu elements remain accessible despite evasions.
   * Prevent excessive speed or unpredictable movement from frustrating players.
   * Immediate reset functionality to restore menu stability.
7.8. Whack-a-Button
   * Gameplay Mechanics & Interaction:
   * Buttons randomly appear and quickly disappear across the menu screen.
   * Players must quickly click or tap these buttons to earn points.
   * Difficulty progressively increases with faster button appearances.
   * Visual Elements:
   * Visually distinct buttons with playful animations.
   * Engaging visual and auditory feedback upon successful clicks ("whack").
   * Optional score display.
   * Technical Requirements:
   * Efficient randomized spawning mechanism with adjustable timing.
   * Smooth and responsive input handling for both desktop (mouse) and mobile (touch).
   * Optimized animations.
   * Possible Edge Cases & Issues:
   * Ensuring randomly appearing buttons don't obstruct essential menu navigation.
   * Balanced difficulty progression.
   * Immediate reset button for quick restoration of the original menu state.
7.9. Mini Rocket
   * Gameplay Mechanics & Interaction:
   * Players control a cursor (PC) or touch point (mobile) that launches small rockets toward menu elements.
   * Rockets explode on impact, creating fireworks and playful visual effects.
   * Purely playful interaction with no scoring objective.
   * Visual Elements:
   * Visually appealing rocket animations (trails) and vibrant fireworks explosions (particle effects).
   * Technical Requirements:
   * Efficient particle system integration (Unity) for rocket and explosion effects.
   * Responsive input handling for mouse (desktop) and touch (mobile).
   * Optimized visuals for performance.
   * Possible Edge Cases & Issues:
   * Preventing rockets and explosions from obscuring essential menu functionality.
   * Ensuring immediate reset to the original menu state via the reset button.
   * Preventing excessive particle effects from impacting performance.
7.10. Catch the Icon
   * Gameplay Mechanics & Interaction:
   * Icons (related to the game's theme or menus) fall from the top of the screen.
   * Players control a platform or character at the bottom, moving horizontally to catch icons and score points.
   * Controls: Arrow keys/mouse (PC), touch/drag (Mobile).
   * Visual Elements:
   * Bright, visually distinct icons with smooth falling animations.
   * Smooth animation for the player-controlled catching element.
   * Visual/sound feedback on catch.
   * Technical Requirements:
   * Efficient 2D physics and collision detection for smooth gameplay.
   * Intuitive controls for desktop and mobile.
   * Optimized performance.
   * Possible Edge Cases & Issues:
   * Ensuring falling icons don't obscure essential navigation buttons.
   * Clear distinction between game elements and core UI.
   * Providing quick reset functionality.
   * Preventing player paddle from going off-screen.
7.11. Hidden Maze
   * Gameplay Mechanics & Interaction:
   * Activated by interacting with a specific UI element (e.g., clicking an arrow pointing off-screen).
   * The view slides horizontally to reveal a maze integrated into the background/menu design.
   * Players navigate a character or cursor through the maze.
   * Controls: Arrow keys/WASD (PC), on-screen controls or touch/drag (Mobile).
   * Reaching specific points (e.g., where an arrow points off the other side) causes the screen to slide again, potentially revealing more maze or the exit.
   * Successfully navigating the entire maze reveals a humorous message: "Congratulations, you have wasted your time!".
   * Visual Elements:
   * Maze path subtly integrated or revealed against the menu background.
   * Smooth screen sliding transitions.
   * Clear visual representation of the player's position within the maze.
   * Final humorous text display.
   * Technical Requirements:
   * Maze logic (pathfinding, collision detection against walls).
   * Screen transition system (sliding effect).
   * Responsive controls.
   * Accurate collision detection.
   * Possible Edge Cases & Issues:
   * Ensuring seamless transitions between maze sections/screens.
   * Clear reset functionality (slides view back immediately).
   * Preventing interference with essential menu elements during sliding or maze gameplay.
   * Preventing player from getting stuck in maze geometry.
7.12. Asteroid Menu Shooter
   * Gameplay Mechanics & Interaction:
   * The cursor becomes a controllable spaceship.
   * Players move around the screen, firing projectiles to destroy menu elements styled as falling asteroids.
   * Players earn points for each asteroid destroyed, creating a playful interaction.
   * Visual Elements:
   * Menu elements visually transformed into asteroid-style objects.
   * Animated spaceship cursor clearly designed to match menu aesthetics.
   * Smooth projectile firing animations and explosion effects upon asteroid hits.
   * Technical Requirements:
   * Efficient handling of 2D spaceship controls and projectile physics.
   * Smooth collision detection between projectiles and asteroids.
   * Lightweight particle effects optimized for all devices.
   * Possible Edge Cases & Issues:
   * Ensuring menu functionality remains accessible despite interactions.
   * Immediate reset button availability for easy restoration of the normal menu.
   * Balancing difficulty to keep gameplay engaging without frustration.
7.13. Bubble Shooter (Easter Egg)
   * Gameplay Mechanics & Interaction:
   * Integration: Takes place within a designated area of the main menu/lobby UI.
   * Activation: Triggered by a specific user interaction (TBD). Upon activation: Menu letters within the area change color; initial bubbles/letters appear.
   * Core Loop: Player aims a launcher at the bottom, shoots colored bubbles upwards (bouncing off side walls). Bubbles stick to other bubbles or colored letters. Match 3+ of the same color (bubbles or letters) to pop them.
   * Detachment: Bubbles/letters fall if they are no longer connected (directly or indirectly) to the "ceiling" cluster after a pop. Floating letters only fall if attached to a falling cluster.
   * Goal: Clear all bubbles and colored letters from the area.
   * Rapid Fire: System must handle rapid firing inputs without bugs or visual glitches (like bubble phasing).
   * Progression ("Round 2+"):
   * Upon clearing the board, display "Congratulations you've wasted your time here's round two" text.
   * Reset the board with a new layout.
   * Starting from the second shot of Round 2 (and subsequent rounds), the entire ceiling cluster advances downwards slightly after every 2 shots fired.
   * Controls (PC & Mobile):
   * PC: Mouse aims (with trajectory guideline including bounces), Left Click fires.
   * Mobile: Touch/drag aims (with trajectory guideline), Release touch or tap button fires.
   * Scoring System: No explicit scoring system; goal is to clear the board.
   * Visual Style & Assets (2D):
   * Style: Integrates cleanly with menu UI theme.
   * Bubbles/Letters: Stylized colored bubbles and menu letters using a clear color palette.
   * Launcher: Simple graphic at the bottom showing current bubble color (and optionally next).
   * Game Area: Clear visual boundary within the UI.
   * Effects: Popping animation/particles, falling animation, aiming line visual. "Round 2" text display.
   * Technical Requirements (Unity):
   * Engine: Unity (C#) using UI system/2D tools.
   * UI Integration: Logic to identify menu letters, change color, treat as game objects. Confine game to specific UI Panel.
   * Aiming/Trajectory: Calculate and display aiming line with wall bounces.
   * Bubble Physics/Grid: Logic for bubble movement, sticking (hex grid or physics), robust collision detection preventing phasing/tunneling.
   * Match-3 Logic: Detect matches including colored letters.
   * Cluster Detachment: Detect and remove unattached bubbles/letters, respecting floating letters.
   * State Management: Handle game start, board clear detection, "Round 2+" state (reset, enabling/triggering ceiling advance).
   * Input Handling: Process rapid fire input reliably.
   * Performance: Must be lightweight and responsive within the main menu.
   * Possible Edge Cases & Issues:
   * Aiming precision, stuck bubbles, bubble phasing/tunneling (critical), performance, boundary interactions, reset reliability, ceiling advance logic complexity, visual clarity of letters vs bubbles.
8. Multiplayer Structure
   * Real-time: Gameplay synchronization between players must occur in real-time. Aim for a high-quality feel similar to popular online games.
   * Cross-Platform: Players on different supported platforms (PC, Mobile) must be able to play together seamlessly.
   * Lobby System:
   * Players can create or join game lobbies.
   * Ability to invite friends (requires a basic friend system or integration with platform services).
   * Clear display of players in the lobby.
   * Host migration or server-authoritative structure to handle disconnections.
   * Scalability: Backend infrastructure (Node.js) must be designed to handle a growing number of concurrent players.
   * Networking: Utilize efficient networking protocols (WebSockets via Socket.io or similar) managed by the Node.js backend. Unity frontend communicates with this backend.
   * Global Player Representation:
   * Default View: By default, players see other participants in real-time using their selected character models within the game world.
   * Name Display: Player names are displayed above character models for identification.
   * Ghost Mode Setting: A global game setting allows players to optionally render other players as less intrusive "ghost" forms (e.g., semi-transparent, outline) instead of full models. This setting applies across all applicable mini-games.
   * Global Synchronization & Fairness:
   * Environment Sync: For competitive fairness, all players in a session must experience the exact same sequence of procedurally generated hazards, obstacles, level segments, and power-up placements. This requires server-side control (via shared seed or dictated spawns).
   * Instanced Collectibles: Unless otherwise specified for a specific game mechanic, common collectibles like Coins are instanced per player. Collection is handled client-side and does not affect availability for others.
   * Power-up Effects: Power-ups generally affect only the player who collects them. Visual effects of power-ups on other players should be synchronized where appropriate.
   * Global Interaction Rule:
   * No Direct Player Collision: Players generally cannot physically collide with or impede each other. Competition is score/objective-based.
   * Global Game State Management:
   * Round End Condition: Unless specified otherwise (like games with lives), rounds typically end when the last active player is eliminated.
   * Elimination Procedure: Eliminated players are generally shown their final score and offered Wait/Spectate options until the round concludes for all participants.
   * Results: Final results are displayed in a ranked list based on the game's scoring criteria.
   * Global Network Considerations:
   * Real-time Feel: Prioritize network strategies (e.g., update frequency ~10-20Hz, interpolation/prediction) that achieve a smooth, real-time experience. Balance smoothness with bandwidth efficiency.
   * Server Authority: The server is the authority for session management, environment synchronization, and final score validation to ensure fairness.
9. Scoring System
   * Mini-Game Specific: Each mini-game will have its own primary scoring metric (e.g., distance, time survived, objects collected, points earned).
   * Standard Score Calculation: Unless otherwise specified (like for Subway Surfers multiplier), the final score for ranking combines the primary metric (Distance/Time/etc.) with a bonus for collected Coins, typically Score = PrimaryMetric + (Coins * 1).
   * Tournament Scoring: In tournament mode, scores from each mini-game are aggregated (details TBD, may require normalization) to determine overall rankings.
   * Tie-breaking: Establish rules for handling score ties in both individual games and overall tournament results.
10. Customization
   * Player Avatars (Global Approach):
   * Goal: Allow players to customize their in-game appearance using various 3D models (or 2D sprites where applicable), including standard ones, potential future shop items, and user-provided models like 3D scans (e.g., of friends). Customization is selected per mini-game (e.g., a player chooses their Jetpack Joyride character separately from their Subway Surfers character).
   * Model Input & Loading: The system requires a robust process for importing, managing, and selecting custom character models/sprites appropriate for each game's dimension and style. A mechanism to load the player-selected model/sprite at runtime for use in the specific mini-game is essential.
   * Automated Rigging/Animation (Goal): The development workflow (AI/MCP controlling Blender/Unity tools) should attempt to automate rigging (adding a skeleton) and retargeting standard mini-game animations (running, jumping, flying, etc.) onto imported custom models where applicable (primarily 3D games).
   * Complexity Note: This is technically challenging, especially for diverse inputs like scans. Success depends on model quality and tool capabilities. Define clear expectations and fallback strategies.
   * Fallback Strategy (If Auto-Rig/Animation Fails): Implement fallbacks (Decision needed during development/testing):
   * Option A (Static Model/Sprite): Use a single, static pose.
   * Option B (Model/Sprite Swapping): Switch between pre-posed models/sprites based on state (e.g., run pose, fly pose).
   * Option C (Simplified Rig): Attach model to a standard invisible skeleton (3D only).
   * Option D (Criteria): Enforce specific requirements for custom models (e.g., must be humanoid-rigged for complex 3D animations).
   * Adaptive Collision: Collision detection logic must adapt to the visual shape/size of the loaded character model/sprite (e.g., Mesh Colliders, configurable primitive colliders, sprite-based colliders).
   * Configurable Effects: Support defining attachment points (e.g., "back", "feet") per character model/sprite for game-specific effects (like jetpack thrust).
   * Asset Pipeline: The technical architecture must support swapping placeholder assets with high-quality, Blender-generated assets seamlessly. The AI (Cursor/Roo/Cline) should assist in automating the import and integration of these assets into Unity.
11. Technical Details
   * Frontend Engine: Unity (C#) - Chosen for robust 2D/3D capabilities, performance, cross-platform support, and MCP integration potential.
   * Backend: Node.js - Chosen for scalable, real-time multiplayer handling, using WebSockets (e.g., Socket.io). Manages game state, lobbies, player data synchronization.
   * Graphics: Mix of 2D and 3D visuals tailored to each mini-game. Leverage Unity's rendering capabilities. Aim for visually appealing presentation, avoiding a "boring" flat look, especially for games like Subway Surfers.
   * Asset Creation: Blender + AI (MCP Integration) - Primary workflow for generating high-quality 2D/3D models, textures, and animations. AI assists in creation within Blender.
   * Asset Integration: AI-assisted (Cursor/Roo/Cline) import and configuration of Blender assets (.blend, FBX) into the Unity project.
   * Target Platforms: PC (Windows, macOS, potentially Linux) and Mobile (iOS, Android). Design and controls must be adapted for both keyboard/mouse and touch interfaces.
   * Physics: Utilize Unity's built-in physics engine for both gameplay and interactive UI elements (Easter eggs).
   * AI Development IDE: Cursor / Roo / Cline or similar AI-native IDE with MCP support.
12. AI Development Approach (Vibe Coding)
   * Methodology: Primarily use "vibe coding" principles, directing the AI assistant (within Cursor/Roo/Cline) to generate, modify, and test code.
   * Planning: Utilize this PRD and a detailed TODO.md file (broken down step-by-step) to guide the AI. Keep these documents updated.
   * Iteration: Develop features incrementally, one at a time.
   * Testing: Implement automated tests (using Unity's testing framework or appropriate Node.js testing tools) for core mechanics and features after each feature is developed. Run tests frequently. Fix failing tests before proceeding.
   * Version Control: Use Git and GitHub from the start. Commit frequently after tests pass for stable save points. Use AI to assist with Git commands if needed. Roll back to previous commits if AI introduces breaking changes that are difficult to fix.
   * Rules: Maintain a rules.md file with global and project-specific rules for the AI assistant (e.g., prefer modifying existing code, keep functions small, follow security best practices, adhere to chosen architecture).
   * Refactoring: Periodically ask the AI to review and refactor code sections for maintainability, performance, and adherence to best practices.
13. Security & Maintainability
   * Security:
   * Follow backend security best practices (input validation, rate limiting, authentication/authorization checks).
   * Avoid storing sensitive keys directly in code; use environment variables or secure configuration methods.
   * Use established libraries for authentication rather than rolling custom solutions.
   * Periodically ask AI to perform security audits on the codebase.
   * Maintainability:
   * Emphasize modular code structure in both Unity (C#) and Node.js.
   * Keep functions and classes focused on single responsibilities.
   * Use clear naming conventions.
   * Ensure AI generates comments for complex logic.
   * Regularly refactor to prevent code brittleness.
14. Future Considerations / Expansion
   * Addition of more complex mini-games (e.g., 3D platformers, puzzle games).
   * In-game Shop: Implement a shop interface where players can spend persistently collected coins to unlock cosmetic items (characters, skins, etc.) specific to each mini-game.
   * Leaderboards (global, friends).
   * Achievements system.
   * Enhanced social features (profiles, friend management).
   * Platform-specific integrations (e.g., Game Center, Google Play Games).
   * AI-driven game elements (e.g., adaptive difficulty, AI opponents in more games).
   * Cloud save support.
